<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
  
  <link rel="stylesheet" href="http://34.200.98.64:3000/templates/base.css">
<link rel="stylesheet" href="http://34.200.98.64:3000/templates/prism.css">  

  <title>The Lucca Logs</title>
</head>
<body>

  <div class="sidebar">    
    <header><b>The Lucca Logs</b></header>
    <br>
    <b>General</b>
    <ul>
      <li><a href="/index">Index</a></li>
      <li><a href="/test">Just testing</a></li>                 
      <li><a href="/about">About myself</a></li>
      <li><a href="/all">All posts</a></li>
      <li><a href="/random">Random post</a></li>
    </ul>

    <p><a href="/website"><b>Website Things</b></a></p>

    <p><a href="/programming"><b>Programming</b></a></p>

    <p><a href="/music"><b>Music</b></a></p>

    <p><a href="/album-review"><b>Album reviews</b></a></p>    
      
    <p><a href="/github-readme"><b>GitHub READMEs</b></a></p>

    <b>Links</b>
    <ul>
      <li><a href="https://www.github.com/ChromeUniverse">GitHub</a></li>
      <li><a href="https://www.linkedin.com/in/lucca-rodrigues-61b8271b3/">LinkedIn</a></li>
      <li><a href="https://www.youtube.com/channel/UCjpQ2w6Di2f-tyCiK6mVGlA">YouTube</a></li>
    </ul>

  </div>

  <div class="topbar">
    <div class="title">
      <b>The Lucca Logs</b>
    </div>
    <br>
    <div class="topbar-button">
      <button>ðŸ“œ</button>    

      <div class="topbar-menu">

        <div class="topbar-menu-item"><a href="/all"><b>All posts</b></a></div>
        <div class="topbar-menu-item"><a href="/programming"><b>Programming</b></a></div>
        <div class="topbar-menu-item"><a href="/music"><b>Music</b></a></div>
        <div class="topbar-menu-item"><a href="/website"><b>Website Things</b></a></div>
        <!-- <div class="topbar-menu-item"><a href="/programming"><b>Programming</b></a></div> -->
    
      </div>
    </div>
    

  </div>

  <div class="main">        
    <h1 id="trying-out-prismjs">Trying out Prism.js</h1>
<hr>
<div class="header"><div class="date">Published on 2021-5-30</div><div class="groups">Groups: <a href="/all">all</a>, <a href="/programming">programming</a>, <a href="/webdesign">webdesign</a></div></div><p>I&#39;ve just added a new library to my website, <a href="https://prismjs.com/">Prism.js</a>, for improved code snippets. </p>
<p>Since my posts often place a heavy emphasis on coding, I figured that having quality code snippets with adequate syntax highlighting (among other things) will add a lot of value to my programming-related posts. </p>
<p>And from the looks of it, Prism is working pretty well. Just to demonstrate, here are a couple of example code snippets.</p>
<p>The first example code snippet is a small part of the main <code>bot.py</code> file from my <a href="https://github.com/ChromeUniverse/RedstoneBot">RedstoneBot</a> project, written in Python.</p>
<pre><code class="language-python"># module imports
import asyncio
import aiohttp
import discord
from discord.ext import commands

# function imports from files
from login import login
from format_help import format_help
from get_status import get_status
from get_times import get_times
from activate import activate
from deactivate import deactivate
from reactivate import reactivate
from register import register
from leave_queue import leave_queue
from unregister import unregister
from get_list import get_list

# member role functions
from role_functions import (
    check_user,
    check_admin,
)

# database functions
from db_functions import (
    link,
    guild_in_db,
    IP_in_db,
    get_serverID,
    get_looping,
    update_looping,
    deleteEntry,
)

# credentials
from credentials import (
    username,
    password,
    token,
)

# -----------------------------------------------------------------
# Discord setup
# -----------------------------------------------------------------



# command prefix
client = commands.Bot(command_prefix = &#39;!redstone &#39;)

# Redstone dust reddish color for Rich Embeds
redstoneRed = discord.Colour.from_rgb(221,55,55)

# removing default Help command
client.remove_command(&#39;help&#39;)

# bot startup
@client.event
async def on_ready():
    # retrieving aiohttp ClientSession
    global session_list
    session = session_list[0]

    # logging in to ploudos.com
    login_status_code = await login(username, password, session)
    print(&#39;\nLogin status code: &#39; + str(login_status_code))

    print(&#39;Bot is ready to roll!\n&#39;)



# -----------------------------------------------------------------
# Discord commands
# -----------------------------------------------------------------


# help command - shows useful help page w/ commands + other things
@client.command()
async def help(ctx):

    title, content = format_help()
    # format and send rich embed
    page=discord.Embed(
        title=title,
        description=content,
        colour=redstoneRed
    )
    await ctx.send(embed=page)





# ping command - replies with &quot;Pong!&quot; + connection latency in miliseconds
@client.command()
async def ping(ctx):
    await ctx.send(f&#39;Pong! :ping_pong: Connection latency is {round(client.latency * 1000)}ms&#39;)
</code></pre>
<p>For the second example, I&#39;ll try a code snippet in C++. This is a <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a> parser and evaluator that I wrote a couple of months ago with the help of my friend <a href="https://github.com/qrno">Eduardo Quirino</a>.</p>
<pre><code class="language-c++">/*
    -- RPN Parser --

    Parses and evaluates reverse polish
    notation expressions.

*/


#include &lt;iostream&gt; // input/output
#include &lt;typeinfo&gt;
#include &lt;stack&gt;    // stack data structure
#include &lt;queue&gt;
#include &lt;math.h&gt;   // quick maths
#include &lt;string&gt;   // guess what this does?
#include &lt;sstream&gt;  // stringstreams

#include &lt;vector&gt;

using namespace std;


/*
numberStack.push(5); -&gt; puts element into stack
numberStack.pop();   -&gt; removes top element
numberStack.top();   -&gt; gets top element

numberStack.size()   -&gt; number of elements
numberStack.empty()  -&gt; [BOOL] whether it is emtpy
*/




// Returns whether string is a number
bool isNumber(string s) {
  // looping over chars in string

  // checking for empty input
  if (s.size() == 0) return false;

  for (int i = 0; i &lt; s.size(); i++) {
    char letter = s[i];

    // check if letter isn&#39;t digit or decimal point
    if (letter &lt; &#39;0&#39; || letter &gt; &#39;9&#39;) {
      // checks minus case
      if ((letter == &#39;-&#39; &amp;&amp; i == 0) &amp;&amp; s.size() &gt; 1)
        continue;
      // checks decimal point case
      if (letter == &#39;.&#39;) continue;

      return false;
    }
  }
  // found an actual number
  return true;
}





// Splits expression into queue
queue&lt;string&gt; string2queue(string expression) {
  queue&lt;string&gt; token_queue;
  /*
  token_queue.push(3)   -&gt; enqueues element
  token_queue.pop()     -&gt; dequeues element
  token_queue.front()   -&gt; gets first element
  */

  // empty string token
  string token = &quot;&quot;;

  // iterating through expression
  for (int i = 0; i &lt; expression.size(); i++) {
    char letter = expression[i];

    // adding letter to token
    if (letter != &#39; &#39;) token += letter;
    else {      // found a whitespace char
      if (!token.empty()) { // protects against multiple whitespaces
        // ready to push token to queue
        token_queue.push(token);
        //cout &lt;&lt; &quot;This is token, right here: &quot; &lt;&lt; token &lt;&lt; endl;
        token=&quot;&quot;;
      } // else, just another whitespace, keep going
    }
  }
  // adds token at the end of the expression (edge case)
  if ( !token.empty() ) token_queue.push(token);

  return token_queue;
}




// print elements in a queue
void print_queue(queue&lt;string&gt; q){
  int i = 0;
  while (!q.empty())
  {
    cout &lt;&lt; i &lt;&lt; &quot;-th element: &quot; &lt;&lt; q.front() &lt;&lt; endl;
    q.pop();
    i++;
  }
  cout &lt;&lt; endl;
}




// evaluate RPN expression
double solve(string expression) {

  // generating queue of tokens
  queue&lt;string&gt; token_queue = string2queue(expression);

  /*
  // print copy of token_queue
  queue&lt;string&gt; q_copy = token_queue;
  print_queue(q_copy);
  */


  // big &#39;ol stack of numbers
  stack&lt;double&gt; numberStack;

  while (!token_queue.empty()) {
    // getting the token at the front of the queue
    string token = token_queue.front();
    token_queue.pop();

    // checking if token is a number
    if (isNumber(token)) {
      //cout &lt;&lt; token &lt;&lt; &quot; is number\n&quot;;

      // Converting string token to double
      double numToken = stod(token);
      // pushing number to stack
      numberStack.push(numToken);
    } else {
      // found an operator
      if (numberStack.size() &lt; 2) {
        cout &lt;&lt; &quot;SYNTAX ERROR - Not enough numbers in stack\n&quot;;
        exit(1);
      }

      // getting and popping the RH operand
      //cout &lt;&lt; numberStack.top() &lt;&lt; &quot; is a: &quot; &lt;&lt; typeid(numberStack.top()).name() &lt;&lt; endl;
      double b = numberStack.top() + 0.0;
      numberStack.pop();
      //cout &lt;&lt; b &lt;&lt; &quot; is: &quot; &lt;&lt; typeid(b).name() &lt;&lt; endl;
      // getting and popping the LH operand
      //cout &lt;&lt; numberStack.top() &lt;&lt; &quot; is a: &quot; &lt;&lt; typeid(numberStack.top()).name() &lt;&lt; endl;
      double a = numberStack.top() + 0.0;
      numberStack.pop();
      //cout &lt;&lt; a &lt;&lt; &quot; is: &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;

      // operation result
      double result = 0;

      // executing operation
      if (token == &quot;+&quot;) result = a + b;           // addition
      else if (token == &quot;-&quot;) result = a - b;      // subtraction
      else if (token == &quot;*&quot;) result = a * b;      // multiplication
      else if (token == &quot;/&quot;) result = a / b;      // division
      else if (token == &quot;^&quot;) result = pow(a, b);  // exponentiation
      // checking for invalid operators
      else {
        cout &lt;&lt; &quot;INVALID INPUT - This operator doesn&#39;t exist\n&quot;;
        exit(1);
      }

      // pushing result to number stack
      numberStack.push(result);
    }
  }

  // cheking the size of the number stack
  int stackSize = numberStack.size();

  // If we got anything other than one, something went wrong.
  if (stackSize != 1) {
    cout &lt;&lt; &quot;SYNTAX ERROR - Not enough operators\n&quot;;
    exit(1);
  }

  // Pop result and print it
  double result = numberStack.top();
  numberStack.pop();

  return result;
}





// list of test expressions &amp; expected output
vector&lt; pair&lt;string, double&gt; &gt; tests{
  /*1*/{&quot;2 3 +&quot;, 5},
  /*2*/{&quot;2 3 *&quot;, 6},
  /*3*/{&quot;-123123 -123123 +&quot;, -246246},
  /*4*/{&quot;2 2 + 3 - 123 - 24 *&quot;, -2928},
  /*5*/{&quot;5 3 + 7 15 * 8 + -&quot;, -105},
  /*6*/{&quot;2.00 3.99 +&quot;, 5.99},
  /*7*/{&quot;4.00 2.00 /&quot;, 2.00},
  /*8*/{&quot;2.0 5.0 ^&quot;, 32.0},
};





// run test expressions
bool runTests() {
  bool success = true;

  // looping through tests
  for (auto test : tests) {
    // solve expression
    double result = solve(test.first);

    // comparing solve() output with expected output
    if (result != test.second) {
      // current test failed
      cout &lt;&lt; &quot;FAILED TEST &quot; &lt;&lt; test.first &lt;&lt; endl;
      cout &lt;&lt; &quot;EXPECTED &quot; &lt;&lt; test.second &lt;&lt; &quot; GOT &quot; &lt;&lt; result &lt;&lt; endl;
      success = false;
    }
  }
  return success;
}






// main program function
int main() {

  // run test expressions
  bool success = runTests();
  if (success) cout &lt;&lt; &quot;SUCCESS!&quot;;


  string expression;

  // read RPN expression
  cout &lt;&lt; &quot;Enter RPN: &quot;;
  getline(cin, expression);

  // evaluate expression
  double result = solve(expression);

  // print output
  cout &lt;&lt; result &lt;&lt; endl;
  

  return 0;
}
</code></pre>
<p>Finally, I&#39;m going to try out some Javascript. This is the classic memoized Fibonacci sequence program in JS:</p>
<pre><code class="language-js">var fibList = [];

function fib(num) {
  if (num == 1 || num == 2) {
    return 1;
  } else {
    return fib(num-1) + fib(num-2);
  }
}

function main(num){
  console.log(&quot;The first &quot; + num + &quot;Fibonacci numbers are: &quot;);
  for (var i = 1; i &lt; num+1; i++) {
    fibNum = fib(i);
    console.log(&quot;Fib number &quot; + i + &quot;: &quot; + fibNum);
  }
}

main(50);
</code></pre>
<p>Yep, Prism.js is definetely working as advertised. ðŸ˜ƒ</p>
<p>Expect to see it used quite regularly in my future posts.</p>

    <hr>
    <footer>Â© Lucca Rodrigues 2021</footer>    
  </div>

  <script src="http://34.200.98.64:3000//scripts/prism.js"></script>
</body>
</html>